<p>&mdash;&mdash;&mdash;&mdash;安装<br />安装python 3.6+<br />ubuntu 18已经自带python3.6了,下面是ubuntu 16.04上的安装方法.<br />sudo add-apt-repository ppa:deadsnakes/ppa<br />sudo apt install python3.6<br />curl https://bootstrap.pypa.io/get-pip.py | sudo python3.6<br />deadsnakes这个源可以支持到python3.9，所以上面的3.6可以替换成你想安装的版本<br /><br />安装paramiko库<br />sudo pip3 install paramiko<br /><br />安装AT<br />把解压缩得到的AT文件夹放在你想安装的位置，然后运行python3 PATH_TO_AT/init.py<br />一路会有提示，一般回车即可。<br /><br />安装完成之后还不能立刻运行命令，因为AT的安装原理是把自己的目录加入到系统路径，要等到下一次重启才生效，在此之前，可以用sudo来运行(sudo路径是立刻生效的)。<br /><br />在非ubuntu系统上，"添加系统路径"这一步会失败，需要你手动把AT目录加入到你的系统PATH里。<br /><br />&mdash;&mdash;&mdash;&mdash;本地命令<br />trace <br />跟踪打印一个软链接<br /><br />version <br />查看系统上已安装的某程序的全部版本<br />eg.<br />version python<br />version python3<br /><br />mklink <br />命令格式: mklink symlink target<br />target可以写成绝对路径或相对路径，当写成相对路径时，表示从符号文件的位置走到target。<br />eg.<br />mklink /usr/bin/xx&nbsp; /usr/bin/python3.6<br />mklink&nbsp; /usr/bin/yy ./python3.6<br />xx和yy指向的是同一个文件.<br /><br /><br />&mdash;&mdash;&mdash;&mdash;AT命令集<br />AT命令主要提供了一系列基于ssh的远程操作<br />命令格式: AT operation arg1 arg2 ...<br /><br /><br />AT assign-priv-key user -kname<br />分配给user一个私钥，私钥取自name指定的KEY<br /><br />user 要分配至的用户<br />-k&nbsp;&nbsp; 指定私钥的来源 <br />name可以是一个user name或KEY name,例如:<br />AT assign-priv-key jack -kBen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #把用户Ben的私钥赋给jack.<br />AT assign-priv-key jack -kshared&nbsp;&nbsp;&nbsp; #把名为shared的KEY的私钥赋给jack.<br />KEY是AT用于管理密钥的一个概念,一个KEY由一个公钥和一个私钥组成，以一个包含id_rsa和id_rsa.pub的目录形式存放。所以Ben的~/.ssh目录也是一个KEY，只不过它需要用用户名指代。shared KEY是AT自动生成的，位于/root/.AT/keys目录，目前AT只支持这一个"具名"KEY. <br />shared KEY是AT的缺省KEY,上面第二句命令可以写成:<br />AT assign-priv-key jack<br /><br />分配私钥的过程是硬拷贝，除了拷贝id_rsa,还会把id_rsa.pub也拷贝过去。因为密钥一旦分配出去，AT就不知道这个密钥是从哪儿来的了，所以赶紧把公钥也拷贝过去，以免要用的时候无从找起。<br /><br />AT assign-pub-key user@server -kname [--password]<br />分配公钥是把本地KEY的id_rsa.pub追加到远程服务器user账号下的authorized_keys文件。<br /><br />AT的远程操作都包含一个自动登录的过程，自动登录时会依次尝试 当前用户，root用户(如果有权限的话)的密钥。<br />自动登录功能作为一项基础设施提供给每个操作，但具体登录哪个远程用户是由每个操作自己自己决定的,通常是root用户。<br />user@server这种格式可能会给你造成困扰，因为它的习惯上的含义是"指定以user身份登录server"，但在AT命令里里不是。就像前面所说的，大多数AT操作都有自己预设的登录用户作为远程操作者，它们不接受指定。这个前导user字段会被各个操作以自己的方式来解释。像比，assign-pub-key把这个字段解释成"要分配至的用户"。而add-remote-user则把这个字段解释成"要添加的用户"。<br /><br />--password用来强制密码登录，这个选项主要是给assign-pub-key用，因为它面对的常常是一台崭新的服务器。<br /><br />AT --config server<br />配置服务器信息, 这个命令调用外部编辑器打开一个叫server.json的文件<br />AT目前不接受直接在命令行输入ip,所以操作一台远程服务前，要先编辑这个文件。<br />初始状态的server.json大概长这样:<br />{<br />&nbsp;&nbsp;&nbsp; "comment":"",<br />&nbsp;&nbsp; &nbsp;"servers":<br />&nbsp;&nbsp; &nbsp;[<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ip":"127.0.0.1"<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;},<br /><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"name":"centos7",<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ip":"0.0.0.0",<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ssh_port":22<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;]<br />}<br />服务器列表以json数组的形式存储在'servers'字段,第一个服务器是最简单的形式，第二个是完整的格式。缺省情况下，ssh_port是22,name是s0,s1,s2.. ，即 "s" + indexof(server).<br />servers列表的第一个位置保留给本机，添加服务器时需要从第二个开始.<br /><br />下面是一个实例，演示怎么通过assign操作实现密钥登录:<br />mz@bogon:~$ mv ~/.ssh ~/.ssh2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #我的工作目录已经有私钥了，先挪开<br />mz@bogon:~$ sudo AT assign-priv-key mz<br />key source: /root/.AT/keys/shared/<br />copy /root/.AT/keys/shared/id_rsa to /home/mz/.ssh/id_rsa ...<br />copy /root/.AT/keys/shared/id_rsa.pub to /home/mz/.ssh/id_rsa.pub ...<br /><br />mz@bogon:~$ AT --config server<br />mz@bogon:~$ cat ~/.AT/server.json<br />{<br />&nbsp;&nbsp;&nbsp; "comment":"",<br />&nbsp;&nbsp; &nbsp;"servers":<br />&nbsp;&nbsp; &nbsp;[<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ip":"127.0.0.1"<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;},<br /><br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"name":"centos7",<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ip":"45.77.178.195",<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;"ssh_port":22<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br />&nbsp;&nbsp; &nbsp;]<br />}<br />&nbsp;&nbsp; &nbsp;<br />mz@bogon:~$ sudo AT assign-pub-key root@centos7 --password<br />key source: /root/.AT/keys/shared/<br />发送远程命令: id -u root &gt; /dev/null<br />login root@45.77.178.195, password:<br />创建socket: 45.77.178.195:22&nbsp;&nbsp; [success]<br />发送远程命令: mkdir -p /root/.ssh<br />发送远程命令: touch /root/.ssh/authorized_keys<br />/root/.ssh/.authorized_keys.cook ===&gt; /root/.ssh/authorized_keys<br />发送远程命令: chown -R `id -u root` /root/.ssh<br />发送远程命令: chmod 700 /root/.ssh<br />发送远程命令: chmod 600 /root/.ssh/.authorized_keys.cook<br />发送远程命令: mv '/root/.ssh/.authorized_keys.cook' '/root/.ssh/authorized_keys'<br /><br />mz@bogon:~$ AT ssh2 root@centos7<br />创建socket: 45.77.178.195:22&nbsp;&nbsp; [success]<br />login root@45.77.178.195, using '/home/mz/.ssh/id_rsa' ... [success]<br />root@centos7 $ <br /><br />最后成功用ssh2连上了服务器，ssh2是AT自带的一个测试命令，有时候openssh连不上，这个命令能连上.<br /><br /><br />其余的操作清单如下:<br />AT add-remote-user&nbsp; user@server<br />添加一个远程用户,并创建家目录; 指定登录shell为bash; 添加进sudo用户组<br /><br />AT del-remote-user user@server<br />AT list-remote-users @server<br /><br />AT set-password user@server 设置用户口令<br /><br />AT enable-password&nbsp; @server<br />AT disable-password @server<br />开启/禁用密码登录<br /><br />AT enable-pubkey&nbsp; @server<br />AT enable-pubkey&nbsp; @server<br />开启/禁用公钥登录<br /><br />AT alt-ssh-port @server newport 修改ssh端口<br /><br />AT init @server --password<br />初始化一台服务器,包括:<br />关闭selinux(针对redhat系)<br />给远程root用户分配公钥(公钥来自当前用户名下)<br />开启公钥登录<br />禁用密码登录<br /><br /><br />&mdash;&mdash;&mdash;&mdash;scp2<br />scp2基本目的是为了利用上server.json里的配置，以便在命令行里用服务器名字代替ip.<br />这个工具在拷贝行为上，跟unix的传统风格有较大差异:<br />1, 复制一个目录，unix用-r,scp2用-d.<br />2, unix系的拷贝工具，像cp, scp,当它们发现复制目标是已存在的目录时，会自动的把拷贝对象扔到那个目录．例如:<br />cp .vim ~/.vim -r<br />复制的结果是，生成~/.vim/.vim这样一个拷贝．<br />在scp2下这样做会报错:<br />scp2 .vim ~/.vim -d<br />[error] file or directory exists: /home/kongque/.vim&nbsp; [copy conflicts]<br />这是一个保护性错误，因为scp2是支持目录的对拷(说对拷其实不对，确切说是，当复制目标已经存在时，使用拷贝策略来解决冲突)的，但这种行为又很危险，所以需要你加上拷贝策略来确认. <br />scp2有两个拷贝策略:<br />-a 全拷贝<br />-x 差异拷贝<br />scp2 .vim ~/.vim -da&nbsp;&nbsp;&nbsp; #相当于用当前目录下的.vim替换掉~/.vim<br />scp2 .vim ~/.vim -dx&nbsp;&nbsp;&nbsp; #跳过完全相同的文件<br />-x跟-a的区别，仅仅在于它可能会节省实际拷贝的工作量，从最终的拷贝结果来看，两者都是生成一个跟src一模一样的dest.请务必记住这条原则，这是拷贝的原始语意，否则这种伴随隐式重命名的拷贝，很容易让脑子浆糊．<br />3, 如果你需要往一个目录里拷贝，在目录末尾加上/<br />scp2 .vim&nbsp; ~/.vim/<br /><br />scp2底层包装的是linux的rsync命令，所以它提供了一部分rsync的特性,其中主要包含5个diff属性:<br />(下面的介绍约定本地目录为src,远程目录为dest)<br />-n 本地新增的文件(new added)<br />-u 本地缺少的文件(本地删除，也可能是服务器端有添加行为) 这个选项用字母u是取它的形状跟n相反,下面的w和m也是一样<br />-m 本地修改过的文件(modified)<br />-w 本地比远程旧的文件(可能是服务器端发生过编辑行为)<br />-e 完全相同的文件<br />numwe加起来是一个diff的全集，这些选项之间组合，可以做一些常见的操作:<br />scp2 -n src dest -d&nbsp; 复制src里新增的文件到服务器<br />scp2 -u src dest -d "复制"src里缺少的文件,实际上是往远程递交删除操作<br />scp2 -m src dest -d 复制src里修改过的文件到服务器<br />scp2 -num src dest -d 这有点儿像git的一次commit changes<br />scp2 -numw src dest -d 等同于上面的-x操作,差异复制<br />有些选项(主要是-w和-e)或选项组合是不支持的，像比单用一个w:<br />scp2 -w src dest -d<br />这样会报错，因为rsync提供的选项没有办法组合出这个逻辑．<br /><br />这5个选项现在临时放在scp2里，将来可能会挪到别的命令里．</p>
